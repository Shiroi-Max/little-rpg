#include "screen.h"
#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <math.h>

static Screen screen;

// Private function for managing SDL errors.
void error_Screen()
{
    printf("%s\n", SDL_GetError());
    exit(EXIT_FAILURE);
}

// Private function for capturing the closing window event.
static int handler(void *userdata, const SDL_Event *event)
{
    if ((event->type == SDL_APP_TERMINATING || event->type == SDL_QUIT) && screen.active)
    {
        screen.active = 0;
        return (0);
    }
    if (event->type == SDL_WINDOWEVENT && event->window.event == SDL_WINDOWEVENT_CLOSE)
    {
        screen.active = 0;
        return (0);
    }
    return (1);
}

void create_Screen(char title[], int w, int h)
{
    if (SDL_Init(SDL_INIT_VIDEO) < 0)
        error_Screen();

    screen.window = SDL_CreateWindow(title, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, w, h, 0);
    if (screen.window == NULL)
        error_Screen();

    screen.surface = SDL_GetWindowSurface(screen.window);
    if (screen.surface == NULL)
        error_Screen();

    screen.renderer = SDL_CreateSoftwareRenderer(screen.surface);
    if (screen.renderer == NULL)
        error_Screen();

    if (SDL_SetRenderDrawBlendMode(screen.renderer, SDL_BLENDMODE_BLEND) == -1)
        error_Screen();

    screen.strokeColor.r = 0;
    screen.strokeColor.g = 0;
    screen.strokeColor.b = 0;
    screen.strokeColor.a = 255;

    screen.fillColor.r = 255;
    screen.fillColor.g = 255;
    screen.fillColor.b = 255;
    screen.fillColor.a = 255;
    screen.width = w;
    screen.height = h;

    screen.active = 1;
    SDL_SetEventFilter((SDL_EventFilter)handler, NULL);
}

void free_Screen()
{
    screen.active = 0;
    SDL_DestroyWindow(screen.window);
    SDL_DestroyRenderer(screen.renderer);
    SDL_Quit();
}

int width_Screen()
{
    return screen.width;
}

int height_Screen()
{
    return screen.height;
}

int isActive_Screen()
{
    SDL_PumpEvents();
    return screen.active;
}

void wait_Screen(int ms)
{
    SDL_Delay(ms);
}

void update_Screen()
{
    if (SDL_UpdateWindowSurface(screen.window) == -1)
        error_Screen();
}

int isKeyPressed_Screen(SDL_Scancode scancode)
{
    const Uint8 *state = SDL_GetKeyboardState(NULL);
    return state[scancode];
}

int isButtonMousePressed_Screen(int button)
{
    int state = SDL_GetMouseState(NULL, NULL);
    return state & SDL_BUTTON(button);
}

void mouseCoords_Screen(double *x, double *y)
{
    int xi, yi;
    SDL_GetMouseState(&xi, &yi);
    if (x)
        *x = xi;
    if (y)
        *y = yi;
}

void strokeColor_Screen(int r, int g, int b, int a)
{
    screen.strokeColor.r = r;
    screen.strokeColor.g = g;
    screen.strokeColor.b = b;
    screen.strokeColor.a = a;
}

void fillColor_Screen(int r, int g, int b, int a)
{
    screen.fillColor.r = r;
    screen.fillColor.g = g;
    screen.fillColor.b = b;
    screen.fillColor.a = a;
}

void drawBackFilling_Screen(int r, int g, int b, int a)
{
    if (SDL_SetRenderDrawColor(screen.renderer, r, g, b, a) == -1)
        error_Screen();
    if (SDL_RenderClear(screen.renderer) == -1)
        error_Screen();
}

void drawPoint_Screen(double x, double y)
{
    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    if (SDL_RenderDrawPoint(screen.renderer, x, y) == -1)
        error_Screen();
}

void drawLine_Screen(double x1, double y1, double x2, double y2)
{
    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    if (SDL_RenderDrawLine(screen.renderer, x1, y1, x2, y2) == -1)
        error_Screen();
}

void drawTriangle_Screen(double x1, double y1, double x2, double y2, double x3, double y3)
{
    if (SDL_SetRenderDrawColor(screen.renderer, screen.fillColor.r, screen.fillColor.g, screen.fillColor.b, screen.fillColor.a) == -1)
        error_Screen();
    if (y1 > y2)
    {
        double t = x1;
        x1 = x2;
        x2 = t;
        t = y1;
        y1 = y2;
        y2 = t;
    }
    if (y2 > y3)
    {
        double t = x2;
        x2 = x3;
        x3 = t;
        t = y2;
        y2 = y3;
        y3 = t;
        if (y1 > y2)
        {
            double t = x1;
            x1 = x2;
            x2 = t;
            t = y1;
            y1 = y2;
            y2 = t;
        }
    }
    double xl = x1;
    double xr = x1;
    double dxl = (x2 - x1) / (y2 - y1);
    double dxr = (x3 - x1) / (y3 - y1);
    int y = y1;

    y2 = floor(y2);
    while (y < y2)
    {
        if (SDL_RenderDrawLine(screen.renderer, xl, y, xr, y) == -1)
            error_Screen();
        xl += dxl;
        xr += dxr;
        y = y + 1;
    }
    xl = x2;

    dxl = (x3 - xl) / (y3 - y);
    dxr = (x3 - xr) / (y3 - y);
    while (y < y3)
    {
        if (SDL_RenderDrawLine(screen.renderer, xl, y, xr, y) == -1)
            error_Screen();
        xl += dxl;
        xr += dxr;
        y = y + 1;
    }
    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    if (SDL_RenderDrawLine(screen.renderer, x1, y1, x2, y2) == -1)
        error_Screen();
    if (SDL_RenderDrawLine(screen.renderer, x2, y2, x3, y3) == -1)
        error_Screen();
    if (SDL_RenderDrawLine(screen.renderer, x3, y3, x1, y1) == -1)
        error_Screen();
}

void drawRectangle_Screen(double x, double y, double w, double h)
{
    SDL_Rect r;
    r.x = x;
    r.y = y;
    r.w = w;
    r.h = h;

    if (SDL_SetRenderDrawColor(screen.renderer, screen.fillColor.r, screen.fillColor.g, screen.fillColor.b, screen.fillColor.a) == -1)
        error_Screen();
    if (SDL_RenderFillRect(screen.renderer, &r) == -1)
        error_Screen();
    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    if (SDL_RenderDrawRect(screen.renderer, &r) == -1)
        error_Screen();
}

void drawCircle_Screen(double x, double y, double r)
{
    int dy;
    r = round(r);

    if (SDL_SetRenderDrawColor(screen.renderer, screen.fillColor.r, screen.fillColor.g, screen.fillColor.b, screen.fillColor.a) == -1)
        error_Screen();
    for (dy = 0; dy <= r; dy++)
    {
        double dx = floor(sqrt((2.0 * r * dy) - (double)(dy * dy)));
        for (int px = x - dx; px <= x + dx; px++)
        {
            if (SDL_RenderDrawPoint(screen.renderer, px, y + r - dy) == -1)
                error_Screen();
            if (SDL_RenderDrawPoint(screen.renderer, px, y - r + dy - 1) == -1)
                error_Screen();
        }
    }

    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    double error = -r;
    double px = r - 0.5;
    double py = 0.5;
    double cx = x - 0.5;
    double cy = y - 0.5;

    while (px >= py)
    {
        if (SDL_RenderDrawPoint(screen.renderer, cx + px, cy + py) == -1)
            error_Screen();
        if (SDL_RenderDrawPoint(screen.renderer, cx + py, cy + px) == -1)
            error_Screen();

        if (px != 0)
        {
            if (SDL_RenderDrawPoint(screen.renderer, cx - px, cy + py) == -1)
                error_Screen();
            if (SDL_RenderDrawPoint(screen.renderer, cx + py, cy - px) == -1)
                error_Screen();
        }

        if (py != 0)
        {
            if (SDL_RenderDrawPoint(screen.renderer, cx + px, cy - py) == -1)
                error_Screen();
            if (SDL_RenderDrawPoint(screen.renderer, cx - py, cy + px) == -1)
                error_Screen();
        }

        if (px != 0 && py != 0)
        {
            if (SDL_RenderDrawPoint(screen.renderer, cx - px, cy - py) == -1)
                error_Screen();
            if (SDL_RenderDrawPoint(screen.renderer, cx - py, cy - px) == -1)
                error_Screen();
        }

        error += py;
        ++py;
        error += py;

        if (error >= 0)
        {
            --px;
            error -= px;
            error -= px;
        }
    }
}

static unsigned short int letters[95][13] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // space :32
    {0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, // ! :33
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
    {0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
    {0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
    {0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
    {0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
    {0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
    {0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
    {0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
    {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
    {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
    {0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
    {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
    {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
    {0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
    {0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
    {0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
    {0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
    {0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
    {0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
    {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
    {0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
    {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
    {0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
    {0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
    {0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
    {0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
    {0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
    {0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
    {0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
    {0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
    {0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
    {0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
    {0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
    {0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
    {0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
    {0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
    {0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
    {0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
    {0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
    {0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
    {0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
    {0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
    {0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
    {0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
    {0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
    {0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
    {0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00} // :126
};

void drawText__Screen(char *st, double x, double y)
{
    int i = 0;
    if (SDL_SetRenderDrawColor(screen.renderer, screen.strokeColor.r, screen.strokeColor.g, screen.strokeColor.b, screen.strokeColor.a) == -1)
        error_Screen();
    while (st[i])
    {
        int letter = st[i] - ' ';
        for (int row = 0; row < 13; row++)
        {
            int mask = 128;
            for (int column = 0; column < 8; column++)
            {
                if (mask & letters[letter][row] && SDL_RenderDrawPoint(screen.renderer, x + i * 9 + column, y + 13 - row) == -1)
                    error_Screen();
                mask /= 2;
            }
        }
        i++;
    }
}

char *readText_Screen(int x, int y, int max, char *title)
{
    SDL_Event event;
    char *text = malloc(sizeof(char) * max);
    char *msg = malloc(sizeof(char) * (max + 1));
    int length = 0;
    int quit = 0;
    int cursor = 0;
    int tick = 0;
    SDL_PumpEvents();

    while (SDL_PollEvent(&event))
        ;
    SDL_StartTextInput();
    while (!quit)
    {
        while (SDL_PollEvent(&event))
        {
            switch (event.type)
            {
            case SDL_KEYDOWN:
                if (event.key.keysym.sym == SDLK_BACKSPACE && length > 0 && cursor > 0)
                {
                    for (int i = cursor; i < length; i++)
                        text[i - 1] = text[i];
                    length--;
                    text[length] = '\0';
                    cursor--;
                }

                if (event.key.keysym.sym == SDLK_RETURN)
                    quit = 1;
                if (event.key.keysym.sym == SDLK_ESCAPE)
                    quit = 1;
                length = 0;
                if (event.key.keysym.sym == SDLK_LEFT && cursor > 0)
                    cursor--;
                if (event.key.keysym.sym == SDLK_RIGHT && cursor < length)
                    cursor++;
                break;

            case SDL_TEXTINPUT:
                int eventlength = 0;
                char *textptr = event.text.text;
                for (char *iptr = event.text.text; *iptr; iptr++)
                    eventlength++;
                if (eventlength > 1)
                    textptr++;

                if (*textptr > 0 && length < max)
                {

                    if (cursor < length)
                        for (int i = length; i >= cursor; i--)
                            text[i + 1] = text[i];

                    for (char *iptr = textptr; *iptr; iptr++)
                    {
                        text[cursor] = *iptr;
                        if (*iptr == -62 || *iptr == -61)
                        {
                            iptr++;
                            cursor--;
                        }
                        length++;
                        cursor++;
                    }
                }
                break;

            case SDL_QUIT:
                quit = 1;
                length = 0;
                screen.active = 0;
                break;

            default:
                break;
            }
        }
        for (int i = 0; i < length; i++)
            msg[i] = text[i];
        for (int i = length; i < max; i++)
            msg[i] = ' ';
        msg[max] = '\0';
        fillColor_Screen(192, 192, 192, 255);
        strokeColor_Screen(64, 64, 64, 255);
        drawRectangle_Screen(x, y, (max + 1) * 9, 40);

        fillColor_Screen(255, 255, 255, 255);
        strokeColor_Screen(128, 128, 128, 255);
        drawRectangle_Screen(x + 1, y + 20, (max + 1) * 9 - 2, 19);
        strokeColor_Screen(0, 0, 0, 255);
        drawText__Screen(title, x + 4, y + 2);
        strokeColor_Screen(0, 0, 0, 255);
        drawText__Screen(msg, x + 4, y + 22);
        tick++;
        if (tick < 20)
            drawLine_Screen(x + 4 + cursor * 9, y + 33 + 1, x + 4 + cursor * 9, y + 23);
        if (tick == 25)
            tick = 0;
        update_Screen();
        wait_Screen(40);
    }
    SDL_StopTextInput();
    char *output = NULL;
    if (length > 0)
    {
        output = malloc(sizeof(char) * (length + 1));
        for (int i = 0; i < length; i++)
            output[i] = text[i];
        output[length] = '\0';
    }
    free(msg);
    free(text);
    return output;
}

void drawImage_Screen(Image Image, double x, double y, double w, double h)
{
    SDL_Rect src;
    double ow = w;
    double oh = h;
    src.x = 0;
    src.y = 0;
    src.w = Image->surface->w;
    src.h = Image->surface->h;
    if (x < 0)
    {
        src.x = Image->surface->w * (-x / w);
        w = w + x;
    }
    if (y < 0)
    {
        src.y = Image->surface->h * (-y / h);
        h = h + y;
    }

    SDL_Rect dest;
    dest.x = x < 0 ? 0 : x;
    dest.y = y < 0 ? 0 : y;
    dest.w = dest.x + w > screen.width ? screen.width - dest.x : w;
    dest.h = dest.y + h > screen.height ? screen.height - dest.y : h;

    src.w = Image->surface->w * (dest.w / ow);
    src.h = Image->surface->h * (dest.h / oh);

    if (SDL_BlitScaled(Image->surface, &src, screen.surface, &dest) == -1)
        error_Screen();
}

double widthImage_Screen(Image Image)
{
    return Image->surface->w;
}

double heightImage_Screen(Image Image)
{
    return Image->surface->h;
}

void freeImage_Screen(Image Image)
{
    SDL_FreeSurface(Image->surface);
    free(Image);
}

Image readImage_Screen(char *file, int transparency)
{
    SDL_Surface *surface = SDL_LoadBMP(file);
    if (surface == NULL)
    {
        printf("Error reading file '%s'.\n1) Check that such a file really exists.\n2) If the file exists, it is probably not in uncompressed BMP format.\n\n", file);
        exit(EXIT_FAILURE);
    }

    if (transparency)
    {
        if (surface->format->palette)
            if (SDL_SetColorKey(surface, SDL_TRUE, *(Uint8 *)surface->pixels) == -1)
                error_Screen();
            else
            {
                switch (surface->format->BitsPerPixel)
                {
                case 15:
                    if (SDL_SetColorKey(surface, SDL_TRUE, (*(Uint16 *)surface->pixels) & 0x00007FFF) == -1)
                        error_Screen();
                    break;
                case 16:
                    if (SDL_SetColorKey(surface, SDL_TRUE, *(Uint16 *)surface->pixels) == -1)
                        error_Screen();
                    break;
                case 24:
                    if (SDL_SetColorKey(surface, SDL_TRUE, (*(Uint32 *)surface->pixels) & 0x00FFFFFF) == -1)
                        error_Screen();
                    break;
                case 32:
                    if (SDL_SetColorKey(surface, SDL_TRUE, *(Uint32 *)surface->pixels) == -1)
                        error_Screen();
                    break;
                }
            }
    }

    Image Image = calloc(1, sizeof(struct Image));

    SDL_PixelFormat *pixelformat = SDL_AllocFormat(SDL_PIXELFORMAT_ARGB8888);
    if (pixelformat == NULL)
        error_Screen();

    Image->surface = SDL_ConvertSurface(surface, pixelformat, 0);
    if (Image->surface == NULL)
        error_Screen();

    SDL_FreeFormat(pixelformat);

    SDL_FreeSurface(surface);
    return Image;
}
